# MongoDB'de Embedded, Referenced Document ve Relation Kavramları (MongoDB Öğreniyoruz 3)

Merhaba Arkadaşlar

Serinin bu makalesinde ilikisel veritabanlarından (RDBMS) aşina olduğumuz relation kavramından bahsedeceğiz.

Makale serisinin diğer yazıları için alttaki linkleri kullanabilirsiniz.
- [Distributed Sistemlerde Consistency Kavramı ve Document DB Karşılaştırmaları (MongoDB Öğreniyoruz 1)](1.distributed-systems.md)
- [MongoDB Kurulum ve CRUD İşlemleri (MongoDB Öğreniyoruz 2)](2.kurulum-crud-islemleri.md)
- [MongoDB'de Embedded, Referenced Document ve Relation Kavramları (MongoDB Öğreniyoruz 3)](3.embedded-ve-referenced-doküman.md)
- [MongoDB'de Detaylı Sorgulama/Querying (MongoDB Öğreniyoruz 4)](4.query-detaylari.md)
- [MongoDB'de Index Kullanımı ve Sorgu Optimizasyonu (MongoDB Öğreniyoruz 5)](5.indekslerle-calisma-optimizasyon.md)
- [MongoDB'de Aggregation Pipeline Stage Kullanımı (MongoDB Öğreniyoruz 6)](6.aggregation-stages.md)
- [MongoDB'de Aggregation Pipeline Operation Kullanımı ve Sorgu Optimizasyonu  (MongoDB Öğreniyoruz 7)](7.aggregation-operations.md)
- [MongoDB' de Transaction Yönetimi (MongoDB Öğreniyoruz 8)](8-transaction.md)
- [MongoDB' de Role Tabanlı Yetkilendirme (MongoDB Öğreniyoruz 9)](9.security.md)
- [MongoDB'de Büyük Obje ve Dosyaların GridFS ile Yönetimi(MongoDB Öğreniyoruz 10)](10.gridfs-file-management.md)


Uzun süre standart ilişkisel veritabanlarında çalışmış bir çok yazılımcıya için document DB'lerde en ilginç gelen kısım zannediyorum 

MongoDB tarafında ilişki (relation) kavramından ziyade embedded document ve referenced document kavramları kullanılıyor. Referenced document kavramı standart SQL veritabanlarındaki ilişki kavramına benzer bir yapı sunar.

Document DB'ler ilikiyi mümkün olduğunda az kullanmayı önerirken standart SQL veritabanları normalizasyon pratiklerinin uygulanmasını dolayısıyla veri tekrarını engellemek amacıyla tablolar arasında ilişki kurulmasını tavsiye etmektedir. Document DB'ler ise collection'lar arasında mümkün olan en az ilişkiyi sağlamak için **bir yere kadar** veri tekrarının bile yapılmasını tavsiye eder. 


Ön girişten sonra artık teknik detaylara girebiliriz.


**Embedded** veya **nested document** bir dokümanın içine başka bir dokümanın konulması anlamına geliyor. Aşağıdaki dokümanı inceleyelim. Dokümandaki contact ve access alanları bir embedded dokümandır.


![embedded.png](files/embedded.png)
[resim kaynak](https://www.mongodb.com/docs/manual/core/data-model-design/)



**Referenced document** ise başka bir collection'daki (tablodaki) dokümanın bir dokuman içinde referans edilmesidir. Referans işlemi _id alanı ile yapılır. Bu konu biraz aklımıza RDBMS'i getirebilir. Ancak mümkün olduğunca oradaki relation kavramlarında kendimizi uzak tutmaya çalışalım. Document DB'lerin buradaki felsefesi hakikaten çok farklı. Adım adım örneklerle MongoDb'deki relationship kavramını anlamaya çalışacağız.



![files/referenced.png](files/referenced.png)
[resim kaynak](https://www.mongodb.com/docs/manual/core/data-model-design/)

- **Embedded Doküman ile One-to-One İlişki Kurmak**

Kullanıcının adres bilgisi embedded document olarak gösteriliyor. Burada address bilgisi ilgili doküman için bir tane oluşturulmuş. Tabii ki bu adresi açık bir şekilde name alanı gibi de yazabilirdik. Ancak bu şekilde hem bir model oluşturmuş ve bütün adres bilgilerini aynı kavram (doküman) altında toplamış olduk. Hakikaten document DB'ler biraz da gerçek hayatı modellemek ve okunabilir veritabanı oluşturmak için doğmuşlardır. Gerçekte de bir doküman doldurduğumuzda adres bilgisi aynı doküman üzerinde ancak kendi ait alanda doldurulur.


 
```javascript

{
   _id: "joe",
   name: "Joe Bookreader",
   address: {
              street: "123 Fake Street",
              city: "Faketon",
              state: "MA",
              zip: "12345"
            }
}
```

- **Embedded Doküman ile One-to-Many İlişki Kurmak**

Görüleceği üzere bu  sefer kişiye ait adres bilgisi iki tane. Bu durumda embedded dokümanları dizi olarak tutarak one-to-many ilişki kurmuş oluyoruz. Ancak şunu unutmamalıyız ki MongoDB'de bir doküman en fazla 16 MB olabilir. Yani Bu şekilde bir ilişki kurduğumuzda dokümanı çok büyütmememiz gerekiyor. İleride performans ile ilgili konuları işlediğimizde best-practice'lere değiniyor olacağım.

Tekrar etmeyen ve içine bulunduğu dokümanla sıkı bir ilişkisi olan verileri embedded olarak eklemek query'lerinizi ciddi anlamda hızlandıracaktır.

```javascript
{
   "_id": "joe",
   "name": "Joe Bookreader",
   "addresses": [
                {
                  "street": "123 Fake Street",
                  "city": "Faketon",
                  "state": "MA",
                  "zip": "12345"
                },
                {
                  "street": "1 Some Other Street",
                  "city": "Boston",
                  "state": "MA",
                  "zip": "12345"
                }
              ]
 }
```

Daha önce standart SQL veritabanı kullanmış arkadaşların kafasında deli sorular olduğuna eminim. Ama biraz daha sabrederseniz bütün sorularınıza cevap bulacağınıza eminim.


- **Referenced Doküman ile One-to-Many İlişki Kurmak**

Peki burada neden embedded doküman tercih etmedik? Birincisi bir yayınevinin basmış olduğu binlerce kitap olabilir. Bunların hepsini tek dokümanda tutmak limitleri aşmamıza sebep olabilir. İkincisi Burada göz ardı ettik ancak kitap dokümanlarının yayınevi dışında başka bağımlılıkları da olabilir örneğin yazar (author) gibi. Ve yazar verisi tekrar eden yani doğrudan tek bir kitapla ilişki olayan veridir. haliyle bir yazar birden fazla kitap yazabilir. Bu durumda kitap dokümanını ayrı collection da tutarak yazar collection'ı ile de ilişki kurmak mantıklı olabilir.

Örnekte yayınevleri collection'nından bir yayınevi ve kitaplar collection'ından iki kitap alınmıştır.

```javascript

// Yayınevi
{
   _id: "oreilly",
   name: "O'Reilly Media",
   founded: 1980,
   location: "CA",
   books: [123456789, 234567890, ...]
}

//Kitap 1 
{
    _id: 123456789,
    title: "MongoDB: The Definitive Guide",
    author: [ "Kristina Chodorow", "Mike Dirolf" ],
    published_date: ISODate("2010-09-24"),
    pages: 216,
    language: "English"
}

// Kitap 2
{
   _id: 234567890,
   title: "50 Tips and Tricks for MongoDB Developer",
   author: "Kristina Chodorow",
   published_date: ISODate("2011-05-06"),
   pages: 68,
   language: "English"
}
```

Ancak burada halen bir problemimiz var. Yayınevi collection'ı sadece _id alanı ile ilişkileri bir dizide tutarak bile 16 MB'ı zorlayabilir. Ayrıca yayınevine ait kitap sayısı binleri bulmaya başladıkça ileride göreceğiz lookup ile yapacağımız join'lerde yavaşlama neden olacaktır. Bu nedenle unbounded (sınırı olmayan) growing array (büyüyen dizi) durumu oluşabilecek yerlerde ilişkiyi tersine çevirmek mantıklı olacaktır. Yani kitap üzerinde yayınevi bilgisini reference olarak tutmak.

Kitap dokümanları üzerinde publisher_id alanında yayınevi id'si kaydedilmiş.

```javascript
// Yayınevi
{
   _id: "oreilly",
   name: "O'Reilly Media",
   founded: 1980,
   location: "CA"
}

//Kitap 1 
{
   _id: 123456789,
   title: "MongoDB: The Definitive Guide",
   author: [ "Kristina Chodorow", "Mike Dirolf" ],
   published_date: ISODate("2010-09-24"),
   pages: 216,
   language: "English",
   publisher_id: "oreilly"
}

// Kitap 2
{
   _id: 234567890,
   title: "50 Tips and Tricks for MongoDB Developer",
   author: "Kristina Chodorow",
   published_date: ISODate("2011-05-06"),
   pages: 68,
   language: "English",
   publisher_id: "oreilly"
}

```

- **Many-to-Many Relationship**

MongoDB'de many-to-many ilişki iki tablo ile kurulur. Aşağıdaki örnekte görüleceği üzere yazarlar ve kitaplar arasında many to many ilişki kurulmuş.

Tabi buradaki örnekte iki tarafta da   unbounded (sınırı olmayan) growing array (büyüyen dizi) durumu oluşabilecek durum olmadığı varsayılıyor. Daha doğrusu öyle bir durum olmayacak şekilde modellenmiş  collection'larla çalışıldığı için bu ilişkinin kurulması mantıklı.




```javascript
//Authors (Yazar) collection

{
  _id: 1,
  name: "Peter Standford",
  books: [1, 2]
}
{
  _id: 2,
  name: "Georg Peterson",
  books: [2]
}

// Books (kitap) collection
{
  _id: 1,
  title: "A tale of two people",
  categories: ["drama"],
  authors: [1, 2]
}
{
  _id: 2,
  title: "A tale of two space ships",
  categories: ["scifi"],
  authors: [1]
}

```

- **Parent Referans ile Model Tree Structure**
Şekildeki gibi bir veri yapımızın olması durumunda nasıl bir model kurabiliriz onu inceleyceğiz. 

![parent.png](files/parent.png)

Dikkat edilirse her doküman için bir parent  kaydı var.


```javascript

db.categories.insertMany( [
   { _id: "MongoDB", parent: "Databases" },
   { _id: "dbm", parent: "Databases" },
   { _id: "Databases", parent: "Programming" },
   { _id: "Languages", parent: "Programming" },
   { _id: "Programming", parent: "Books" },
   { _id: "Books", parent: null }
] )

```

Dokümanları kaydettikten sonra örneğin MongoDB kategorisinin parent'ının Datebase oduğu görülebiliyor.

```javascript
db.categories.findOne( { _id: "MongoDB" } ).parent

//Databases
```
- **Child Referans ile Model Tree Structure**

Üstteki örnekte amacımız bulduğumuz dokümanın parent'ına ulaşmka iken burada child'larına ulaşmaya çalışıyoruz.

Kayıtlarımızı giriyoruz. Bu arada dikkat ederseniz halen aynı collection'a kayır giriyoruz ancak farklı alanları kullanıyoruz. YAni veritabanı şeması veya buna uyma zorunluluğumuz yok.

```javascript
db.categories.insertMany( [
   { _id: "MongoDB2", children: [] },
   { _id: "dbm2", children: [] },
   { _id: "Databases2", children: [ "MongoDB2", "dbm2" ] },
   { _id: "Languages2", children: [] },
   { _id: "Programming2", children: [ "Databases2", "Languages2" ] },
   { _id: "Books2", children: [ "Programming2" ] }
] )

```

Databases2 başlığının child'larına bakalım.dat
```javascript
db.categories.findOne( { _id: "Databases2" } ).children

//[ 'MongoDB2', 'dbm2' ]
```
- **Materialized Path ile Model Tree Structure**

![parent.png](files/parent.png)

Burada amacımız her bir dokümanın tree üzerindeki path'ini kaydederek daha sonra bu herhangi bir path üzerindeki dokümanlara erişmek.

```javascript

db.categories.insertMany( [
   { _id: "Books3", path: null },
   { _id: "Programming3", path: ",Books3," },
   { _id: "Databases3", path: ",Books3,Programming3," },
   { _id: "Languages3", path: ",Books3,Programming3," },
   { _id: "MongoDB3", path: ",Books3,Programming3,Databases3," },
   { _id: "dbm3", path: ",Books3,Programming3,Databases3," }
] )

```

Örneğin path'inde Programming3 geçen dokümanları bulalım.

```javascript

db.categories.find( { path: /,Programming3,/ } )

// [
//   { _id: 'Databases3', path: ',Books3,Programming3,' },
//   { _id: 'Languages3', path: ',Books3,Programming3,' },
//   { _id: 'MongoDB3', path: ',Books3,Programming3,Databases3,' },
//   { _id: 'dbm3', path: ',Books3,Programming3,Databases3,' }
// ]

```

- **Nested Set ile Model Tree Structure**

![parent.png](files/parent.png)

Nested set'lerde hem gidiş nem de dönüş yolu kaydedilir. Tabi bu haliyle bu tarz bir dokümanı kaydetmek zordur. Arada bir dokümanın silindiğini veya araya bir doküman koymak durumunda olduğumuzu düşünün.

```javascript
db.categories.insertMany( [
   { _id: "Books5", parent: 0, left: 1, right: 12 },
   { _id: "Programming5", parent: "Books5", left: 2, right: 11 },
   { _id: "Languages5", parent: "Programming5", left: 3, right: 4 },
   { _id: "Databases5", parent: "Programming5", left: 5, right: 10 },
   { _id: "MongoDB5", parent: "Databases5", left: 6, right: 7 },
   { _id: "dbm5", parent: "Databases5", left: 8, right: 9 }
] )

```
Mesela Programming5 dokümanının bütün child'larını bulmaya çalışalım.



```javascript

var databaseCategory = db.categories.findOne( { _id: "Programming5" } );

db.categories.find( { left: { $gt: databaseCategory.left }, right: { $lt: databaseCategory.right } } );


// [
//   { _id: 'Languages5', parent: 'Programming5', left: 3, right: 4 },
//   { _id: 'Databases5', parent: 'Programming5', left: 5, right: 10 },
//   { _id: 'MongoDB5', parent: 'Databases5', left: 6, right: 7 },
//   { _id: 'dbm5', parent: 'Databases5', left: 8, right: 9 }
// ]


```


```javascript
db.categories.insertMany( [
   { _id: "Books4", parent: 0, left: 1, right: 12 },
   { _id: "Programming4", parent: "Books4", left: 2, right: 11 },
   { _id: "Languages4", parent: "Programming4", left: 3, right: 4 },
   { _id: "Databases4", parent: "Programming4", left: 5, right: 10 },
   { _id: "MongoDB4", parent: "Databases4", left: 6, right: 7 },
   { _id: "dbm4", parent: "Databases4", left: 8, right: 9 }
] )

```

# MongoDB'de Relation Kullanımı Üzerine Best Practice'ler 

Best practice'lerde kaynak dediğimiz doküman ana doküman hedef doküman ise detay doküman olarak kullanılacaktır. Örneğin ürün kategorileri collection'ı kaynak, ürünler collection'ı hedef colleciton olarak kullanılmış olacak.


- Hedef dokümandaki bilgiler kaynak collection'daki diğer dokümanlarda tekrar etmeyen yani bağlanılacak kaynak dokümana özel verilerse 16 MB limitine de takılmıyorsa embedded document olarak kaydedilmelidir. Örneğin kişiye ait adres bilgileri.
- Hedef dokümandaki bilgiler kaynak collection'daki diğer dokümanlarda tekrar ediyor ancak değişmiyorsa yine embedded doküman kullanılmalıdır. Mesela fatura üzerindeki kullanıcı ve ürün bilgileri diğer faturalarda tekrar etse de hedef doküman değişse de kaynak dokümanda (faturada) değişmeyecek bilgilerdir (örneğin fatura adresi, alınan ürünler ve adetleri).
- Eğer üstteki iki durumda ilişki kurulacak hedef doküman sayısı çok fazlaysa, fazladan kastımız 16 MB limitine yaklaşıyorsa o zaman referenced document olarak kaydetmek zorundayız.
- Eğer dokümanlar kaynak collection üzerinde birçok dokümanda tekrar ediyorsa ve hedef doküman da sık değişiyorsa yine referenced doküman olarak kaydetmek daha mantıklı olacaktır.
- Many-to-many durumlarında büyük ihtimal referenced document yapısı her zaman işimizi çözecektir. Örneğin ürün kategori birden fazla ürünle ilişkili ve aynı zamanda bir ürün birden fazla ürün kategorisi ile ilişkili ise ve bu dokümanların değişme ihtimali de varsa referenced document kullanmak mantıklı olacaktır.
- One-to-many referenced ilişkide kaynak doküman içinde tutulan referenced document id sayısı  250-300 gibi bir şeyse $lookup ile okumak yavaşlatacaktır. Ayrıca çok fazla doküman referenced ilişki ile bağlandığında 16 MB sınırına ulaşma tehlikesi de bulunmaktadır. Bu nedenle burada ilişki tersine çevrilebilir. Örneğin ürün kategorilerine ilişkili oldukları ürünlerin id 'lerini eklemektense ilgili ürüne ilişkili olduğu ürün kategorisinin id'sini eklemek daha mantıklı olacaktır.


Kısaca 

- One-to-One:  Key value şeklinde tutmayı tercih edin
- One-to-Few: Embedded document tercih edin
- One-to-Many: Embedded document tercih edin
- One-to-Squillions (belli olmayan 10 da olabilir milyonda):  Referenced document tercih edin
- Many-to-Many: referenced document tercih edin


![relation2.png](files/relation2.png)

Üstte normalize edilmiş standart SQL veritabanındaki şemayı MongoDB'de alttaki 3 şekilde de yapmak mümkün. Hangisini tercih edeceğiniz üstte bahsettiğimiz best practice'lere göre değişecektir.

![relation.png](files/relation.png)

[resim kaynak: MongoDB Application Modernization Guide](https://www.mongodb.com/collateral/mongodb-application-modernization-guide)


Son olarak 
- MongoDB resmi sayfasındaki  "[MongoDB Application Modernization Guide](https://www.mongodb.com/collateral/mongodb-application-modernization-guide)" başlıklı sayfadan ilgili çalışmayı indirip incelemenizi ve 
- MongoDB schema design üzerine kurulu "[Learn MongoDB The Hard Way](http://learnmongodbthehardway.com/)" sayfasını ziyaret etmenizi tavsiye ederim.


umarım faydalı olmuştur.

Makale serisinin diğer yazıları için alttaki linkleri kullanabilirsiniz.
- [Distributed Sistemlerde Consistency Kavramı ve Document DB Karşılaştırmaları (MongoDB Öğreniyoruz 1)](1.distributed-systems.md)
- [MongoDB Kurulum ve CRUD İşlemleri (MongoDB Öğreniyoruz 2)](2.kurulum-crud-islemleri.md)
- [MongoDB'de Embedded, Referenced Document ve Relation Kavramları (MongoDB Öğreniyoruz 3)](3.embedded-ve-referenced-doküman.md)
- [MongoDB'de Detaylı Sorgulama/Querying (MongoDB Öğreniyoruz 4)](4.query-detaylari.md)
- [MongoDB'de Index Kullanımı ve Sorgu Optimizasyonu (MongoDB Öğreniyoruz 5)](5.indekslerle-calisma-optimizasyon.md)
- [MongoDB'de Aggregation Pipeline Stage Kullanımı (MongoDB Öğreniyoruz 6)](6.aggregation-stages.md)
- [MongoDB'de Aggregation Pipeline Operation Kullanımı ve Sorgu Optimizasyonu  (MongoDB Öğreniyoruz 7)](7.aggregation-operations.md)
- [MongoDB' de Transaction Yönetimi (MongoDB Öğreniyoruz 8)](8-transaction.md)
- [MongoDB' de Role Tabanlı Yetkilendirme (MongoDB Öğreniyoruz 9)](9.security.md)
- [MongoDB'de Büyük Obje ve Dosyaların GridFS ile Yönetimi(MongoDB Öğreniyoruz 10)](10.gridfs-file-management.md)


## Database Referans

- https://www.mongodb.com/docs/manual/reference/database-references/
- https://learnmongodbthehardway.com/schema/schemabasics/
- https://www.mongodb.com/docs/manual/tutorial/model-embedded-one-to-one-relationships-between-documents/
- https://www.mongodb.com/docs/manual/tutorial/model-embedded-one-to-many-relationships-between-documents/
- https://www.mongodb.com/docs/manual/tutorial/model-referenced-one-to-many-relationships-between-documents/
- https://www.mongodb.com/docs/manual/tutorial/model-tree-structures-with-parent-references/
- https://www.mongodb.com/docs/manual/tutorial/model-tree-structures-with-child-references/
- https://www.mongodb.com/docs/manual/tutorial/model-tree-structures-with-ancestors-array/
- https://www.mongodb.com/docs/manual/tutorial/model-tree-structures-with-materialized-paths/
- https://www.mongodb.com/docs/manual/tutorial/model-tree-structures-with-nested-sets/
- https://www.mongodb.com/developer/products/mongodb/mongodb-schema-design-best-practices/
